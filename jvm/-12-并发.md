# 并发

## 内存间交互

一个变量如何从主内存拷贝到工作内存,工作内存如何同步到主内存

1. lock(锁定)
    - 作用于主内存变量
    - 把变量表示为一条线程独占
2. unlock(解锁)
    - 作用于主内存变量
    - 释放被锁定的变量

3. read(读取)
    - 作用于主内存变量
    - 将变量从主内存中传输到线程的工作内存中

4. load(载入)
    - 作用于工作内存变量
    - 把read出来的值,放入工作内存的副本中

5. use(使用)
    - 作用于工作内存变量
    - 将工作内存中的变量传递给执行引擎

6. assign(赋值)
    - 作用于工作内存变量
    - 把从执行引擎接收到的值赋值给工作内存变量

7. store(存储)
    - 作用于工作内存
    - 将工作内存中一个变量的值传送到住内存,等待write操作

8. write(写)
    - 作用于主内存
    - 把store操作从工作内存中得到的变量值放入主内存中

8种操作时必须满足以下规则  

1. 不允许`read`和`load`,`store`和`write`操作单独出现

2. 不允许一个线程丢弃它的`assign`操作,工作内存改变必须同步回主内存

3. 不允许一个线程无原因的把数据从工作内存同步回主内存

4. 一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未初始化的变量

5. 一个变量在同一时刻只允许一条线程对其进行`lock`操作,但`lock`操作可以被同一个条线程重复执行多次(需要执行相同次数的`unlock`)

6. 如果对一个变量执行lock操作,那将清空工作内存中此变量的值,在执行引擎使用前需要使用重新执行`load`和`assign`操作

7. 一个变量没有被`lock`操作,不允许执行`unlock`操作

8. 对一个变量执行`unlock`操作之前,必须把此变量同步回主内存(执行`store`,`write`)

## volatile关键字

轻量级同步机制,`volatile`同步主要依赖锁

修饰变量后,该变量将具备两种特性

1. 可见性
   - 当一个线程修改该变量时,新值对其他线程来说是立刻得知的
   - java中运算并不是原子操作,(也就是同步时可能不一致)
2. 禁止指令重新排序

## 原子性,可见性,有序性

- 原子性
  - 基本数据类型访问读写具有原子性
- 可见性
  - 当一个线程修改了共享变量的值,其他线程能够立即的值这个修改
- 有序性
  - 本线程内观察天然有序(线程内表现串行语义),线程观察另一个线程都是无序(指令重排序,工作内存与住内存同步延迟)

## 线程状态

1. 新建(new)
   - 创建后尚未启动的线程

2. 运行(runnable)
   - 正在执行或者等待着cpu分配执行时间的线程

3. 无限期等待(watiting)
   - 处于这种状态的线程不会被分配cpu执行时间
   - `Object.wait()`
   - `Thread.join()`
   - `LockSupport.park()`

4. 限期等待(timed waiting)
   - 处于这种状态的线程不会被分配cpu执行时间,会被幻想
   - `Object.wait()`
     - 需要设置时间
   - `Thread.join()`
     - 需要设置时间
   - `LockSupport.parkNanos()`
   - `LockSupport.parkUntil()`

5. 阻塞(blocked)
    - 在等待着获取一个排他锁,在进入同步区域时,线程将进入这种状态

6. 结束(Terminated)
   - 已终止的线程

> 遇到特定事件发生,状态会随之转换

## 线程安全

5个安全等级

1. 不可变
    - 不可变的对象一定是线程安全的
2. 绝对线程安全
    - 调用者不需要额外的同步代码
3. 相对线程安全
    - 对象独立的操操作是线程安全的,连续调用时需要额外的同步代码(类似`Vector`)
4. 线程兼容
    - 对象本身并不是线程安全的,可以通过正确的同步手段来保证对象在并发环境中可以安全使用
5. 线程独立
   - 无法在多线程环境中使用的代码

几种线程安全的实现方法

1. 互斥同步
    - 保证共享数据统一时刻只被一个线程使用(阻塞和唤醒带来性能问题)
        - `synchronized`
            - 需要从用户态转换到核心态
        - `ReentrantLock`
            - juc包下的
            - 等待可中断
                - 长期无法等待锁的时候,可以选择放弃,改为处理其他事情
            - 公平锁
               - 多个线程等待同一个锁时,必须按照申请锁的时间顺序来依次来获得锁
            - 绑定条件
                - 可以同时绑定多个`Condition`对象
    > 悲观的并发策略

2. 非阻塞同步
    - 不断的重试直到成功为止
        - 由处理器指令完成
          - CAS指令
          - `sun.misc.Unsafe
          - `ABA`问题
    > 乐观的并发策略

3. 无同步方案
    - 可重入代码
        - 不依赖存储在堆上的数据和公用的系统资源(相同入参的结果一只)
    - 线程本地存储
        - 消费队列
        - Web交互模型(Thread-pre-Request)
        - `java.lang.ThreadLocal`

## 锁优化

- 自旋锁
  - 不放弃处理器执行时间,看看持有锁的线程是否很快释放锁,执行忙循环(自旋)
    - jdk默认自旋10次(`-XX:preBlockSpin`),超过时会挂起线程
  - 自适应自旋
    - 自旋时间由前一次在同一个锁上的自旋时间及锁拥有者的状态来决定

- 锁消除
  - 虚拟机及时编译器在运行时,对一些代码上要求同步的,但是检测到不可能存在共享数据竞争的锁进行消除(判断依据是逃逸分析的数据支持)

- 锁粗化
  - 将一连串零碎的操作都对同一个对象加锁,将会把加锁同步范围扩张到整个操作序列的外部

- 轻量级锁
  - 相对于操作系统互斥量来实现的传统锁而言更加轻量,减少性能性能消耗
  - 存在锁竞争时,比传统锁更慢
  - 上锁过程
    1. 进入同步块,检查同步对象没有被锁定
    2. 检测到锁标志位为`01`在当前线程建立名为锁记录(local Record)的空间,存储对象目前的`Mark Word`的拷贝
    3. 使用CAS操作尝试将对象的`Mark Word`更新指向`Lock Record`的指针
    4. 更新成功,线程获得这个对象的锁,并且将对象`Mark Word`的锁标记更新为`00`
        - 更新失败,检查是否指向当前线程的栈帧,是,说明已经获得锁,否,锁被抢占(两条以上的线程抢占同一个锁,锁膨胀为重量级锁,锁标志将变为`10`,`Mark Word`中存储重量级锁的指针)
    5. 解锁,`Mark Word`仍然指向线程的锁记录,使用CAS操作把当前的`Mark Word`替换回去,替换成功,完成整个过程
       - 替换失败,释放锁的同时,唤醒被挂起的线程
- 偏向锁
  - 消除无竞争情况下的同步,进一步提高程序的性能,和轻量锁相比省略了CAS操作
  - 将对象头中的标记设置为`01`偏向模式,同时使用CAS操作把获取到这个锁的线程ID记录到`Mark Word`中
    - 操作成功,该线程持有偏向锁后,进入这个锁相关的同步块都不再进行任何同步操作
    - 当另一个线程尝试获取这个锁,偏向锁模式就结束了,撤销偏向锁
