# 类加载

## 类的生命周期

1. 加载(Loading)
   - 通过类的全限定名来获取定义此类的二进制字节流
   - 将字节流所代标的静态存储结构转化为方法区的运行时数据结构
   - 在内存中生成一个代表这个类的`java.lang.Class`对象
   - 数组类的加载
     - 数组为引用类型,先加载该类型,标识加载该类的加载器
     - 数组非引用类型,标记引导类加载器
     - 数组类的可见性和类一致,若是非引用类型默认为`public`
   - 加载和连接是 ***交叉*** 进行的

2. 连接(LinKing)
    1. 验证(Verigication)
        - 文件格式验证
          - 验证魔数(0xCAFEBABE)
          - 检查常量`tag`
          - 指向常量的索引值是否指向不存在或不符合类型的常量
          - ...
        - 元数据验证
          - 是否有父类
          - 父类是否继承不允许被继承的类
          - ...
        - 字节码验证
           - 通过数据流和控制流分析,确定程序语义是否合法,符合逻辑
        - 符号引用验证
          - 对类自身以外的信息进行匹配性校验,发生在解析阶段
    2. 准备(Perparation)
        - 为类变量分配内存并设置类变量(静态)初始值,分配在方法区
    3. 解析(Resolution)
        - 某些情况下 ***解析*** 在 ***初始化***  之后
        - 将常量池内的符号引用替换为直接引用
        - 符号引用
          - 以一组符号描述所引用的的目标
        - 直接引用
          - 可以是直接指向目标的指针,相对偏移量或能间接定位到目标的句柄
3. 初始化(Initialization)
   - 什么时候初始化
      - 遇到`new` `getstatic` `putstatic` `invokestatic` 四条指令码时并没有被初始化过就触发初始化
      - `java.lang.reflect`包对类进行反射时,如果没有初始化就会触发初始化
      - 初始化一个类时,检查父类有没有初始化,没有,则先触发父类初始化
      - 虚拟机启动时,初始化含有`main`方法的类
      - `java.lang.invoke.MethdHandle`实例后的解析结果为 `REF_getStatic` `REF_putstatic` `REF_incokeStatic`的方法句柄,并且对应的类没有初始化

4. 使用(Using)

5. 卸载(Unloading)

> 这些阶段通常是交叉地混合式进行的
