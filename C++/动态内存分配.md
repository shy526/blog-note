# 动态内存分配

## 静态内存
1. 局部`static`变量
2. 类`static`数据变量
3. 函数之外的任何变量
> 使用前分配,程序结束时销毁,
>>由编译器自动创建和销毁]


## 栈内存
1. 函数内的非`static`对象
> 程序块运行时才存在
>>由编译器自动创建和销毁


## 堆(自由空间或内存池)
- 用来存储动态分配的对象
- 对象想的生存周期由程序控制
- 使用 关键字`new`为对象分配内存 ,`delete`摧毁内存释放对象



## 智能指针
- 和普通指针相同,他负责自动释放所指向的对象

### `shared_ptr`
- 允许多个指针指向同一个对象
- 默认为一个空指针
```
#include <memory>

shared_ptr<string> sptr //声明指向string
```

- 操作


|                      |                                描述                                 |
|:--------------------:|:-------------------------------------------------------------------:|
| make_shared<T>(args) | 返回一个shared_ptr,指向一个动态分配的类型T的对象,使用args初始化对象 |
|  shared_ptr<T>p(q)   |              p是 shared_ptr q的拷贝 ,会递增q中的计数器              |
|         p=q          |         递减p的引用计数,递增q的应用计数,若p计数变为0 则释放         |
|      q.unique()      |                    q.user_count()为1 返回`true`                     |
|    q.user_count()    |                      与p共享对象的智能指针数量                      |

- 引用计数器测试

```c++
#include <memory>
#include<iostream> 
using namespace std;

void functionTest(shared_ptr<int> &p) {
    cout << "函数开始:" << p.use_count() << endl;
    auto q = p;
    cout << "赋值后:" << p.use_count() << endl;
    auto q1(q) ;
    cout << "拷贝后:" << p.use_count() << endl;
}

int main(){
    auto test = make_shared<int>(1);
    cout << "初始化:"<<test.use_count() << endl;
    functionTest(test);
    cout << "函数结束:" << test.use_count() << endl;
    system("pause");
    return 0;
}

```

