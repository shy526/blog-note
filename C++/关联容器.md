# 关联容器
- 高效的查询
- 键值对关联储存
- 主要容器有`map`,`set`
- 标准库提供8个关联容器
    1. `set`或则`map`
    2. 关键字是否重复
        - 允许重复的容器都包含`multi`
    3. 顺序保存或无序 
        - 无序容器都以`unordered`开头
- 分别定义在`map`和`set`头文件中,无序容器定义在`unordered_map`和`unordered_set`
- 默认按关键字升序排序
- map例子 字母数量统计

```c++
map<char, unsigned int>  letter_count;
string a = "abcdfggaaall";
for_each(a.begin(), a.end(), [&letter_count](char s) {
    ++letter_count[s];
});
for_each(letter_count.begin(), letter_count.end(), [](auto s) {cout << s.first <<":"<<s.second<< endl; });
system("pause");
return 0;
```

- set列子 只统计a字母
```c++
map<char, unsigned int>  letter_count;
set<char> exs = { 'a' };
string a = "abcdfggaaall";
for_each(a.begin(), a.end(), [&letter_count,&exs](char s) {
    if (exs.find(s) != exs.end()) {
        ++letter_count[s];
    }
});
for_each(letter_count.begin(), letter_count.end(), [](auto s) {cout << s.first <<":"<<s.second<< endl; });
system("pause");
return 0;

```

## 自定义类型主键
- 自定义主键没有`<`没有运算符就必需传入一个比较的函数指针
- `multiset<自定义类型,decltype(自定义函数)*> test(自定义函数)`
    - `decltype` 指出函数类型


## pair
- 标准库类型
- 头文件在`utility`中
- `map`中的存储键值对的对象
- `first` 是`const`无法修饰的
> `set`迭代器也是`const`

|                       |                描述                |
|:---------------------:|:----------------------------------:|
|     pair<T1,T2> p     |               初始化               |
| pair<T1,T2> p(v1,v2)  | 初始化一个`first`为v1,`second`为v2 |
| pair<T1,T2> p={v1,v2} | 初始化一个`first`为v1,`second`为v2 |
|   make_pair(v1,v2)    | 初始化一个`first`为v1,`second`为v2 |

## insert

- map
    - 返回一个`pair`
        - `first`
            - 原迭代器
        - `second`
            - 插入结果
                - 已经存在为`false`

```c++
map<string, int> word_count;
string word;
while (cin>>word){
    auto result = word_count.insert({ word,1 });
    cout <<"result.first->first:" <<result.first->first 
    << "\nresult.first->second:" << result.first->second
    << "\nresult.second:" << result.second << endl;
}
system("pause");
return 0;
```

- multimap
    - 只返回一个迭代器
```c++
	multimap<string, int> word_count;
	string word;
	int index = 0;
	while (cin>>word){
		auto result = word_count.insert({ word,index++ });
		cout  <<"key:"<< result->first<< endl;
		cout  <<"value:"<< result->second<< endl;
		
	}
	system("pause");
	return 0;
```

## 删除元素

|              |                             描述                             |
|:------------:|:------------------------------------------------------------:|
|  c.erase(k)  |    删除每个关键字为k的元素,返回size_type值(删除元素数量)     |
|  c.erase(p)  | 在c中删除迭代器p,返回p之后的迭代器,若p是尾后迭代器则返回尾后 |
| c.erase(p,e) |             删除迭代器p和e表示范围中的元素返回 e             |


## 访问 

- 下表操作
    - `multi`类型的容器 不能进行下标操作
    - 只可以对非`const`的容器进行操作
- `find`,`count`
    - 重复关键字容器使用`count`会做更多的工作
    - 唯一关键字不受影响
- `at`
    - 只使用用于非`const`的`map`和`unordered_map`
