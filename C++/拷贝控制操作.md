# 拷贝控制操作

## 拷贝构造

- 第一个参数是自身类型的引用,且任何额外参数都有默认值
- 第一个参数几乎都是`const`引用
- 一般都会隐式使用,通常不应该有`explicit`
- 编译器默认生成拷贝函数
  - 依次拷贝非`static`成员中

### 何时发生拷贝初始化

- `=`
- 将一个对象作为实参传递给一个非引用类型的参数
- 从返回类型为非引用类型的函数 返回一个对象
- 用花括号初始化一个数组中的元素或一个聚合类中的成员

## 拷贝赋值

- 未自定义会自动生成一个
- 本质上是一个函数,名为`operator=`的函数
  - `T &operator=(const T& );`

### 什么时候调用析构函数

- 变量离开其作用域
- 当一个对象被销毁,其成员被销毁
- 容器被摧毁,其元素被摧毁
- 动态分配的对象被`delete`时
- 临时,当创建它的完整表达式结束时被销毁

## 析构函数

- 摧毁对象的非`static`数据成员
- 不能被重载,每个类只有唯一个析构函数
- 内置类型没有析构函数
- 析构不会释放指针指向的内存
- 写法

> 一般析构函数和拷贝赋值和拷贝构造绑定在一起重写

```c++
class item{
    public:
        //析构
        ~item();
}
```

## 删除函数

- 使用`=default`显式的要求编译器合成

```c++
class item{
    public:
        //析构
        ~item()=default;
}
```

- `=delete`(不要阻止析构,否则导致对象无法删除)阻止合成

```c++
class item{
    public:
        //析构
        item(const item &)=delete;
}
```

### 一些合成规则

- 如果是私有函数,则函数会被定义为删除
- 如果析构函数是删除的或不可访问的,则拷贝也为删除
- 类有一个`const`的或引用成员,则合成拷贝赋值运算符为删除
- 类有一个引用成员(没有类内初始化)或是类有一个`const`成员,构造函数没有显示定义,则构造函数为删除

## 移动构造

## 移动赋值
