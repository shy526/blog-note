# 拷贝控制操作

## 拷贝构造

- 第一个参数是自身类型的引用,且任何额外参数都有默认值
- 第一个参数几乎都是`const`引用
- 一般都会隐式使用,通常不应该有`explicit`
- 编译器默认生成拷贝函数
  - 依次拷贝非`static`成员中

### 何时发生拷贝初始化

- `=`
- 将一个对象作为实参传递给一个非引用类型的参数
- 从返回类型为非引用类型的函数 返回一个对象
- 用花括号初始化一个数组中的元素或一个聚合类中的成员

## 拷贝赋值

- 未自定义会自动生成一个
- 本质上是一个函数,名为`operator=`的函数
  - `T &operator=(const T& );`

### 什么时候调用析构函数

- 变量离开其作用域
- 当一个对象被销毁,其成员被销毁
- 容器被摧毁,其元素被摧毁
- 动态分配的对象被`delete`时
- 临时,当创建它的完整表达式结束时被销毁

## 析构函数

- 摧毁对象的非`static`数据成员
- 不能被重载,每个类只有唯一个析构函数
- 内置类型没有析构函数
- 析构不会释放指针指向的内存
- 写法

> 一般析构函数和拷贝赋值和拷贝构造绑定在一起重写
>> 析构不直接摧毁成员 

```c++
class item{
    public:
        //析构
        ~item();
}
```

## 删除函数

- 使用`=default`显式的要求编译器合成

```c++
class item{
    public:
        //析构
        ~item()=default;
}
```

- `=delete`(不要阻止析构,否则导致对象无法删除)阻止合成

```c++
class item{
    public:
        //拷贝
        item(const item &)=delete;
}
```

### 一些合成规则

- 如果是私有函数,则函数会被定义为删除
- 如果析构函数是删除的或不可访问的,则拷贝也为删除
- 类有一个`const`的或引用成员,则合成拷贝赋值运算符为删除
- 类有一个引用成员(没有类内初始化)或是类有一个`const`成员,构造函数没有显示定义,则构造函数为删除

## 拷贝控制构造 例子

- h

```h
#ifndef COPY_CONTROL_MESSAGE_H
#define COPY_CONTROL_MESSAGE_H
#include <string>
#include <set>
class Folder;
class Message {
    friend class Folder;
    friend void swap(Message &, Message &);
private:
    std::string contents;
    std::set<Folder *> folders;
public:
    /**
     * 关闭隐式转换构造
     * @param str
     */
    explicit Message(const std::string &str = "") : contents(str) {}

    void save(Folder & );

    void remove(Folder &);

    /**
     * 拷贝
     */
    Message(const Message &);

    /**
     * 赋值
     * @return Message&
     */
    Message &operator=(const Message &);

    /**
     * 析构
     */
    ~Message();
    void info();
};
void swap(Message &, Message &);
class Folder {
    friend class Message;
public:
    explicit Folder(const std::string &str = "") : name(str) {};
    void addMsg(Message *m) {msgs.insert(m);};
    void remMsg(Message *m) {msgs.erase(m);};
    void info();
    ~Folder(){
        for (auto item:msgs) {
            item->folders.erase(this);
        }
    };
private:
    std::string name;
    std::set<Message *> msgs;
};
#endif //COPY_CONTROL_MESSAGE_H
```

- cpp

```c++
#include <iostream>
#include "Message.h"

void Message::save(Folder &folder) {
    folders.insert(&folder);
    folder.addMsg(this);
}

void Message::remove(Folder &folder) {
    folders.erase(&folder);
    folder.remMsg(this);
}

Message::Message(const Message &message) : contents(message.contents), folders(message.folders) {
    for (auto item:message.folders) {
        item->addMsg(this);
    }
}

Message::~Message() {
    for (auto item:folders) {
        item->remMsg(this);
    }
    folders.clear();
}

void swap(Message &l, Message &r) {
    using std::swap;
    //删除左值的消息
    for (auto item:l.folders) {
        item->remMsg(&l);
    }
    //删除右值的消息
    for (auto item:r.folders) {
        item->remMsg(&r);
    }
    //交换集合
    swap(l.folders, r.folders);
    //交换内容
    swap(l.contents, r.contents);
    for (auto item:l.folders) {
        item->addMsg(&l);
    }
    for (auto item:r.folders) {
        item->addMsg(&r);
    }
}

Message &Message::operator=(const Message &r) {
    swap(*this, const_cast<Message &>(r));
    return *this;
}

void Message::info() {
    std::cout << "-----------------------------------" << std::endl;
    std::cout << "消息内容:" << contents << std::endl;
    for (auto item:folders) {
        std::cout << item->name << std::endl;
    }
    std::cout << "-----------------------------------" << std::endl;
}


void Folder::info() {
    std::cout << "姓名:" << name << std::endl;
    std::cout << "收到的信件:" << std::endl;
    for (auto message: msgs) {
        std::cout << message->contents << std::endl;
    }
}

```

## 移动构造

## 移动赋值
