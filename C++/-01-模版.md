# 模版

- 泛型编程的基础

## 定义

```c++
template<typename T> int compare(const T &,cont T&);
```

- 定义参数时 必须使用 `typename`或`class`关键字

> 模版参数列表不能为空

- 非类型模版参数

```c++
template <unsigned u,unsigned m>int  test(const char (&p)[u],const char (&t)[m]){
    return u+m;
}
```

> 非类型模版参数是一个常量值
>> 尽量减少对参数的依赖

## 模版编译

1. 编译模版本身
2. 编译器遇到模版使用时(使用成员函数)
3. 模版实例化时
   - 代码编译错误通知

- 编译器遇到模版定义时,并不会生成代码
  - 只有实例化特定版本时,编译才会生成代码

> 函数模版和类模版成员函数的定义通常在头文件中

## 类模版

```c++
 temeplate<typename T> class A{
 }
 ```

 >>一个类模版的每个实例都会生成一个独立的类型
 >>>在作用域内可以直接使用模版名不必指定模版实参

- 类模版外使用类模版名

 ```c++
template <typename T> className<T> className<T>::operator++(int){}
 ```

- 模版类声明

```c++
template <typename> class className
```

- 友元声明

```c++
//该类是所有classname的实例都是该类友元
template <typename T> friend class className;
//需要模版类声明,用T实例化的模版className2 都是该类的友元
friend class className2<T>;
```

- 模版类型的友元

```c++
template <typename T> class className{
    friend T;
}
```

> 模版允许别名`typedef classname<Type> TypeClassName`