# 特殊技术

## 控制内存分配

- 某应用程序对内存分配有特殊的需求需要定义内存分配的细节

### 重载new和delete

- `new`的调用过程
  1. 调用`operator new`或者`operatot new[]`的标准库函数,分配内存
  2. 编译器运行构造这些对象并初始化
  3. 分配空间并构造完成返回指向该对象的指针

- `delete`的调用过程
  1. 执行对应的析构函数
  2. 调用`operator delete`或者`operatot delete[]`的标准库函数,释放内存

- 八个重载版本
  - 六个承诺不抛出异常
  - 隐式静态

```c++
void *operator new (size_t);
void *operator new (size_t[]);
void *operator delete (void*) noexcept;
void *operator delete[] (void*) noexcept;

void *operator new (size_t,nothrow_t&) noexcept;
void *operator new (size_t[],nothrow_t&) noexcept;
void *operator delete (void*,nothrow_t&) noexcept;
void *operator delete[] (void*,nothrow_t&) noexcept;
```

>> `nothrow_t`定义在`new`头文件中

- 自定义`new`和`delete`
  - 必须在全局作用域或类作用域中定义
  - `new`
    - size_t必须是第一个形参并且不能拥有默认值
      - 表示类型对象所需的字节数
    - 可以定义任何形参
  - `delete`
    - 返回值必须是`void`
    - 第一个形参必须是`void*`

> `void *operator new (size_t, void*)`此版本无法被重载

- `malloc`和`free`函数
  - 定义在`cstdlib`头文件中
  - `malloc`
    - 接收一个带分配的字节数`size_t`,返回指向分配空间的指针或者0表示失败
  - `free`
    - 接收`void*`为`malloc`返回指针的副本,将内存返回给系统

- 重写的示例

```c++
void *operator new (size_t size){
    return malloc(size);
}

void operator delete (void * v) noexcept{
    free(v);
}

```

- 定位`new`
  - 复用某一块内存,减少开辟的消耗

```c++
  //分配内存
  void *v = malloc(sizeof(std::string));
  string *sp = new (v) string ("test");
  std::cout<<*sp<<std::endl;
  std::cout<<sp<<std::endl;

  // sp->~string();
  //重新分配
  string *sp1 = new (v) string ("test1");
  std::cout<<*sp1<<std::endl;
  std::cout<<sp1<<std::endl;
  //这里sp已经被覆盖
  std::cout<<*sp<<std::endl;
  std::cout<<sp<<std::endl;
  //手动析构,摧毁对象
  sp1->~string();
  //释放内存
  free(v);
```

## 运行时类型识别

- `typeid`
  - 返回表达式的类型

  ```c++
    string str="ddf";
    int xx=1;
    int *xxp=&xx;
    double d=2.0;
    std::cout<<typeid(str).name()<<std::endl;
    std::cout<<typeid(xx).name()<<std::endl;
    std::cout<<typeid(xxp).name()<<std::endl;
    std::cout<<typeid(d).name()<<std::endl;
  ```

  - `dynamic_cast`
    - 将基类指针转为派生类指针或引用

  ```c++
  dynamic_cast<派生类类型*> (e)
  ```

## 枚举类型

```c++
//限定作用域
enum class  testType: int{
    in=3,out=4
};
// 不限定作用域
enum  testType2{
    in,out
};

void f(int x){
    std::cout<< x<<std::endl;
}

int main() {
    enum {
        in,out
    };
    f(in);
    f(testType2::in);
    //限定作用域,无法转换
    //f(testType::in);
}
```

## 类成员指针

```c++
class p{
public:
    p(const string &contents) : contents(contents) {}
    //必须是public 否则无法访问,也可以通过静态方法的方式返回类成员指针
    string contents;
}

int main() {
    p xx= p("cc");
    p *pxx=&xx;
    //成员指针声明
    string p::*pc=&p::contents;
    //auto 声明
    auto pca = &p::contents;
    std::cout<< pxx->*pc<<std::endl;
    std::cout<< xx.*pca<<std::endl;
}
```

- 成员函数指针

```c++
class p{
public:
    p(const string &contents) : contents(contents) {}
    string contents;

    const string &getContents() const {
        return contents;
    }
};

int main() {
    p xx= p("cc");
    p *pxx=&xx;
    using pfunct= const string& (p::*)() const;
    const string& (p::*pf)() const;
    pf= &p::getContents;
    pfunct pf2= &p::getContents;

    std::cout<<(xx.*pf)()<<std::endl;
    std::cout<<(pxx->*pf)()<<std::endl;
}
```

> 类函数指针同理,注意调用时`()`的优先级

## 嵌套类

- xx